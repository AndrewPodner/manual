# The Lithium Filters Guide

This guide is meant as an introductory course in creating filters in Lithium applications. Filters are essentially an efficient way of introducing event-driven communication between classes in your application. They allow you to inject bits of logic in the middle of main-line program flow while at the same keeping the API clean, avoiding tight class coupling and some sort of centralized publish/subscribe system.

By the end of this guide, you should feel comfortable in understanding the theory and best practices behind filters, as well as identifying filterable logic in Lithium and creating your own custom filters.

## Aspect-Oriented Programming

Filters in Lithium are inspired by similar concepts in Aspect-Oriented Programming, or AOP. In AOP, an aspect refers to a bit of logic that is scattered throughout an application. Usually, it's a piece of logic that is used in a number of different points in the application, often in completely unrelated systems. 

There are a few examples of aspects that you're probably already familiar with. Logging and authentication are two great examples. Both are used in many different parts of an application, and maintaining something so widespread can get tricky unless you're organized.

## Filter Structure

Long story short, filters are created by encapsulating the main logic for a method inside a closure. That closure is then passed to `Object::_filter()` (or `StaticObject::_filter()`) to allow for chain management.

Applying a custom filter to a filterable method is done by calling the `applyFilter()` method of the object. The first argument specifies the method name to filter, and the second argument is the closure that defines what you want the filter to do.

The following sections will illustrate a few examples that should help you understand how both to apply and create filters.

## Applying Filters: Authentication

Since it's likely to be more common, let's tackle applying filters first. The location of the filter application might depend some on what it is you're filtering, but bootstrap files are often a good choice.

Let's imagine for a moment that we're aiming to add a filter to a Lithium application that checks for authenticated users. Let's start with a basic filter setup, and place it in `app/bootstrap/auth.php`. The thinking here is that we want to inject a bit of authentication verification logic as the dispatcher receives each request. Since `Dispatcher::run()` is filterable, we'll apply the filter there:

{{{
use \lithium\action\Dispatcher;

Dispatcher::applyFilter('run', function($self, $params, $chain) {
	return $chain->next($self, $params, $chain);
});
}}}

This is the basic structure for applying a filter: call `applyFilter()`, hand it the name of the method you'd like to filter, then a closure that implements your filter logic. Let's talk about the parameters involved in the closure.

* `$self`: If the filter is applied on an object instance, then `$self` will be that instance. If applied to a static class, `$self` is a string containing the fully-namespaced class name.

* `$params`: Contains an associative array of the parameters that are passed into the method. You can modify or inspect these parameters before allowing the method to continue.

* `$chain`: Finally, `$chain` contains the list of filters in line to be executed (as an instance of the Filters class). The last item in `$chain` is the original method implementation itself.

The last parameter is important. You can see above that right now the closure returns the results of the logic next in line in the filter chain. Unless you want to short-circuit filter execution (which includes the base logic of the method you're filtering), you'll want to include this somewhere in your filter logic. 

Alright: let's use these parameters to our advantage in creating an authentication setup. If we look at the parameters for `Dispatcher::run()` we can see that accepts two: the current request object, and an options array. 

For this filter, let's inspect the request object (an instance of `lithium\action\Request`) to see what route it matches. Once we've got a URL from the matched route, we can check that against a list of protected controller actions. In the end, it should look something like this:

{{{
use \lithium\action\Dispatcher;
use \lithium\net\http\Router;
use \lithium\action\Response;
use \lithium\security\Auth;

Dispatcher::applyFilter('run', function($self, $params, $chain) {
	//First, define our list of protected actions
	$blacklist = array(
		'/users/report',
		'/users/home'
	);
	
	//Inspect the request to get the URL for the route the request matches
	$matches = in_array(Router::match($params['request']->params, $params['request']), $blacklist);
	
	//If this is a match, check it against an Auth configuration.
	if($matches && Auth::check('default', $params['request'])) {
		//If the Auth check can't verify the user, redirect.
	 	echo new Response(array('location' => '/users/login'));
	}
	
	//Important: return the results of the next filter in the chain.
	return $chain->next($self, $params, $chain);
});
}}}

While this particular setup relies on a few simple Auth configuration steps, hopefully it illustrates how you architect filter application. 

## Applying Filters: Authentication

One more example is common enough to cover: logging. When building a large application, it's handy to log SQL queries made against your data store. It helps in debugging and performance optimization. Let's cover building a quick filter around your data connection logic in order to log SQL statements to a file.

The approach here requires a bit of understanding how Lithium's data layer works. In the setup of your application, you've probably created new database (or other datasource) connections in `app/config/connections.php`. Here's what a simple connection to a MySQL database might look like:

{{{
Connections::add('default', array(
	'type' => 'database',
	'adapter' => 'MySql',
	'host' => 'localhost',
	'login' => 'myusername',
	'password' => 'mypassword',
	'database' => 'app_name'
));
}}}

What we need to do is get a reference to the instance of the actual connection object define here so we can filter it's methods. In this case, we'll use `Connections::get()` to get a reference to the actual adapter handling this connection. Since we've specified 'MySQL' as the adapter type, we'll get an instance of `lithium\data\source\database\adapter\MySql` when we call `Connections::get('default')`.

Looking at the API shows us that there's an `_execute()` method we can filter. It's only parameter is the SQL being executed, and that's exactly what we'll need for our filter logic. Here's one way this could look:

{{{
use \lithium\analysis\Logger;

//Set up the logger configuration to use the file adapter.
Logger::config(array(
	'default' => array('adapter' => 'File')
));

use \lithium\data\Connections;

//Filter the database adapter returned from the Connections object.
Connections::get('default')->applyFilter('_execute', function($self, $params, $chain){
	//Hand the SQL in the params headed to _execute() to the logger:
	Logger::debug(date("D M j G:i:s") . " " . $params['sql']);
	
	//Always make sure to keep the filter chain going.
	return $chain->next($self, $params, $chain);
});
}}}

## Creating Filterable Logic


