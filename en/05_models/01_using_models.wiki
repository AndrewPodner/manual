# Using Models

## Introduction
Models play a key role in nearly every web application. Their main purpose is to abstract
business logic and database operations from higher levels (controllers and views). They 
also act as a gatekeeper and - if properly implemented - make sure that only valid and 
allowed data gets passed through them. Models in Lithium have three main purposes:

 1. provide an abstraction layer to the underlying data source(s),
 2. make common operations (like fetching and storing data) easy to use and
 3. help with validating data.

Also Lithium makes it easy to extend models so that they fit your applications needs. Thanks 
to the nifty autoloading mechanism, models are lazy-loaded and as a result only initialized 
when you need them. In the next chapters you will learn how to use models and perform common 
operations on them. Later chapters will provide you with a more detailed look on models like 
relationships between them and how to extend models to fit your application needs.

## Model Creation and Configuration
Lithium provides you with a general-purpose class that all your models should extend from. 
You can find the `Model` class in the `lithium\data` namespace. If you do nothing more than 
extend it, you instantly get a bunch of functionality that covers basic CRUD as well as more 
complex tasks.

Let's say you want to store and manage blog `Posts` in your database. According to Lithium 
conventions, you create a new file called `Posts.php` in `app/models`. The basic structure 
looks like this:

{{{
<?php
namespace app\models;
class Posts extends \lithium\data\Model {
}
?>
}}}

If you don't provide any extra information, your model will use the `default` connection 
specified in `app/config/connections.php` (and some other defaults that were set for you). 
All this defaults are stored in the `$_meta` variable and therefore you have to override 
it if the defaults don't fit your needs. Let's say you want to use the `backup` connection 
instead of the default one.

{{{
protected $_meta = array(
	'connection' => 'backup'
);
}}}

If you place this inside your `Posts` model, Lithium will merge it with the remaining default 
settings and your model is now using the `backup` connection instead of the default one.

Now that we've got you up and running, let's talk about some basic concepts first before we 
dig into reading and writing data.

## Concepts
Lithium provides you with a bunch of methods that your model can use when it inherits from 
`lithium\data\Model`. Some of these are static, some are not. As a rule of thumb, all static 
methods work with a collection of objects on the database, while non-static methods are tied 
to one single document/record. Consider the following example:

{{{
$post = Posts::first(array('conditions' => array('author' => 'foobar')));

$post->title = "Hello Lithium!";
$post->save();
}}}

The `first()` method is static because it iterates over a bunch of entities in your database 
and returns the first entry where the `author` equals `foobar`. The result you get is an 
instance of a post so all subsequent methods on it are non-static. The second line sets 
the `title` and the third line saves it back to the database. This concept feels natural and 
also has the benefit of instantly knowing on what kind of dataset you're operating.

What you get back from database calls like the one above is not just a plain array (this is 
a big difference for those of you who come from CakePHP) but actually a record/document object 
or a collection of them. This means that you can perform a variety of actions on them if you 
need to. Here's an example:

{{{
// Find all Posts
$posts = Posts::all();

// Get the first and last post of the collection
$first = $posts->first();
$last = $posts->last();

// Iterate over all posts and print out the title
foreach($posts as $post) {
	echo $post->title;
}

// Convert to a plain array
$plain = $posts->to('array');
}}}

Let's get our handy dirty on some code.

## Basic CRUD
CRUD is an abbreviation and stands for Create, Read, Update and Delete. CRUD descibes the basic 
operations that most applications perform against the database. As many database abstraction layers 
Lithium provides you with a rich set of methods that help you with such database operations. At 
the end of this chapter you should be able to create and modify datasets, not tied to any database 
in particular.

### Retrieving Data

### Saving Data

### Updating Data

### Deleting Data