# Controllers

In an MVC application, the controller's job is to handle user input, and handle that request with a specified action. Though the controller action is where action logic is determined, models are often the real workhorses in the request cycle. Keep in mind as you read this guide to keep your controller action trim, with most of the actual functionality spread across models and other classes.

This guide is meant to introduce you to Lithium controllers: their features, behaviors, and the best practices revolving around their usage.

## Controller Actions

Lithium controllers reside inside the `/app/controllers` directory and extend the `\lithium\action\Controller` core class. Let's start by creating a simple controller inside of an application. Controllers are often named after the objects they manage. This way the URL and model line up as well, and it's easy to know where certain bits of logic should live. 

For example, let's create a new controller UsersController. Let's create a new file in `/app/controllers/UsersController.php` that looks like this:

{{{
<?php

namespace app\controllers;

class UsersController extends \lithium\action\Controller { 
	public function index() {
		
	}
}
?>
}}}

Each _public_ function in a controller is considered by the Lithium core to be a routable action. In fact, Lithium's default routing rules make these actions accessible via a browser immediately (in this case /users/index). 

The `index()` action is a special action: if no action name is specified in the URL, Lithium will try to pull up the index action instead. For example, a visitor accessing http://example.com/users/ on your application will see the results of the `index()` action. All other controller actions (unless routed otherwise) are at least accessed by the default route.

For example, we can create a new controller action that would be accessible at `/users/view/`:

{{{
<?php

namespace app\controllers;

class UsersController extends \lithium\action\Controller { 
	public function index() {
		
	}
	
	public function view() {
	
	}
}
?>
}}}

## Accessing Request Parameters

An important part of a controller's role in an application is processing incoming request data in to show the correct response. In this section, we'll show a few examples that should help you how to get data into your controller actions.

### GET Parameters

One of the most user-friendly ways to handle incoming data is through the URL. Information passed along with a GET request is handled a number of different ways, based on your preferences.

The easiest way to handle incoming GET data is by realizing that URL segments that follow the action name are mapped to controller action parameters. Here's a few examples:

{{{
http://example.com/users/view/1  --> UsersController::view($userId);

http://example.com/posts/show/using+controllers/8384/  -->  PostsController::show($title, $postId);
}}}

GET information passed this way is also accessible via the incoming request object:

{{{
http://example.com/users/view/1  --> $this->request->params['args'][0]
}}}

While we'll always recommend using clear URL-based variables, it's important to mention that GET parameters passed as raw query string variables are also available as an attribute of the incoming request:

{{{
http://example.com/users/view?userId=1  --> $this->request->query['userId']
}}}

### POSTed Data

POSTed data is also gathered from the request object. Form field data is found on the request object inside an array with keys named after the input elements generated on the referring page. For example, consider an HTML form that included these elements:

{{{
<input type="text" name="title" value="How to Win Friends and Influence People" />
<input type="text" name="category" value="Self-Help" />
}}}

Accessing these values when submitted to a controller action is as easy as:

{{{
$this->request->data['title'];
$this->request->data['category']
}}}

## Request Flow Control

Occasionally a controller action will want to divert, re-route, or automatically configure the view layer based on an incoming request. There are a number of controller methods to help facilitate request flow handling.

### Redirection

The most basic type of flow control at the controller level is redirection. It's common to redirect a user to a new URL once an action has been performed. This type of control is done through the controller's `redirect()` method. Here's an example of a controller action that redirects the request:

{{{

public function register() {
	// Validate and save user data POSTed to the 
	// controller action found in $this->request->data...
	
	$this->redirect('/users/welcome');
}
	
}}}

The URL specified can be relative to the application or point to an outside resource. The `redirect()` function also features a second `$options` parameter that also allows you to set HTTP status headers, and make decisions about whether or not to `exit()` after a redirect. Be sure to check the API for `lithium\action\Controller::redirect()` for more details.

### Exceptions and Error Handling

Error handling in Lithium is done using the core ErrorHandler class. `ErrorHandler` allows PHP errors and exceptions to be handled in a uniform way. Using `ErrorHandler`s configuration makes it possible to have broad but tightly controlled error handling across your application.

`ErrorHandler` configuration is done by creating a new error-specific bootstrap file that contains your `ErrorHandler` configuration and initialization. To illustrate how this is done, let's consider an imaginary (but common) scenario. Rather than tossing up error messages and stack traces to your users, it's better to create some sort of way to handle exceptions and render user-friendly error pages.

Let's start by creating a way to handle page not found-like errors. If a request can't be routed properly, the Lithium dispatcher will throw an exception to let you know that a controller or view can't be found. Though the example here will be specific to this case, it should provide a mental framework that will allow you to understand how to catch errors and exceptions, and handle them accordingly.

Start by creating a new bootstrap file in /app/config/bootstrap/error.php:

{{{
use \lithium\core\ErrorHandler;

ErrorHandler::apply('lithium\action\DispatchException', 'run', array(), function($exception, $params) {
	var_dump(compact('exception', 'params'));
	die();
});
}}}

This simple example shows how you can create a lambda that handles any `DispatchException`s being thrown in your entire application. The function you pass to apply() can be more involved, depending on what you want to do, however.

Here's a more complete example, showing how you'd actually render a template, and include logging:

{{{
use \lithium\core\ErrorHandler;
use \lithium\analysis\Logger;
use \lithium\template\View;

Logger::config(array('error' => array('adapter' => 'File')));

$render = function($template, $content) {
	$view = new View(array(
		'paths' => array(
			'template' => '{:library}/views/{:controller}/{:template}.{:type}.php',
			'layout'   => '{:library}/views/layouts/{:layout}.{:type}.php',
		)
	));
	echo $view->render('all', compact('content'), compact('template') + array(
		'controller' => 'errors',
		'layout' => 'default',
		'type' => 'html'
	));
};

ErrorHandler::apply('lithium\action\DispatchException', 'run', array(), function($exception, $params) use ($render) {
	Logger::write('error', "Page Not Found...");
	$render('404', compact('exception', 'params'));
});

}}}

If you've got more than one type of exception you want to handle, just add more calls to `apply()` in your error bootstrap file.

### Render Types and Detection

## Using Models 

## Moving Data to the View

## Using Core Libraries (Session, Service, etc)

## Filtering Controller Logic