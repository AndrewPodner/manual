# Model Relationships

The data that applications manipulate is usually structured in some way. Objects have links to other objects, and the model layer that represents that data should reflect the structure inherent in the data it represents and interacts with.

Lithium's data layer offers a way to facilitate data relationships and structure. This guide is meant to show you how to specify and define these data relationships and use them to your advantage as you build your application.

## Defining Model Relationships

Before you define a model relationship in your code, it's important to understand the terminology that describes a relationship between two objects in your system. In Lithium (and elsewhere), a specific set of terms are used to describe model relationships:

 * hasOne: the current object is linked to a single object of another type
 * hasMany: the current object is linked to many objects of another type
 * belongsTo: the current object is owned and marked as related to another object

If you're having a hard time remembering hasOne/hasMany versus belongsTo, just remember this: if the current model contains some sort of marker (like a foreign key), it _belongsTo_ another model.

Defining this object relationship in Lithium is simple: you populate special properties on the model object. For example, let's say we're building an online store. Each `Category` is filled with many `Product` objects. In this case, we'd want to specify `Category` hasMany `Product`. Let's see how this is done:

{{{
<?php
class Category extends \lithium\data\Model {
	protected $hasMany = array('Product');
}
?>
}}}

This simple declaration relies on convention, and is the functional equivalent to this:

{{{
<?php
class Category extends \lithium\data\Model {
	protected $hasMany = array('Product' => array(
		'class'      => 'Product',
		'key'        => 'category_id',
		'conditions' => array(),
		'fields'     => array(),
		'order'      => null,
		'limit'      => null
	));
}
?>
}}}

Unless specified otherwise, the relationship assumes you're using the exact classname specified, with a key that is an under_scored version of the model's class name, suffixed with `_id`. All other sorting and limit options are assumed to be empty.

All of Lithium's model relationships use these same keys (although there's no reason to order or limit hasOne or belongsTo) and can be configured likewise.

## Reading Related Data

## Saving Related Data